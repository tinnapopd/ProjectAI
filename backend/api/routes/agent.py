# --------------------------------------------------------------------------- #
#                              Import Libraries                               #
# --------------------------------------------------------------------------- #
from typing import Dict
from schemas import (
    UserActionRequest,
    ActionResponse,
    GameStartRequest,
    GameState,
    PlayerState,
    StrategyMove,
)

from fastapi import APIRouter, HTTPException
from core.game_engine import GameEngine

router = APIRouter(prefix="/agent", tags=["Agent Development Kit"])

# Store active game sessions (in production, use proper state management)
game_sessions: Dict[str, GameEngine] = {}


@router.post("/start_game")
async def start_game(request: GameStartRequest) -> Dict:
    """
    Start a new strategic wargame session.

    Args:
        request: Game start configuration

    Returns:
        Session information and initial game state
    """
    try:
        # Create a new game engine with real AI agents
        engine = GameEngine(
            business_goal=request.business_goal,
            num_players=len(request.competitors) + 1,
        )

        # Generate a session ID
        session_id = f"session_{len(game_sessions)}"
        game_sessions[session_id] = engine

        return {
            "session_id": session_id,
            "business_goal": request.business_goal,
            "initial_state": request.initial_game_state.model_dump(),
            "message": "Game session created successfully with AI agents",
        }

    except Exception as e:
        raise HTTPException(
            status_code=500, detail=f"Error starting game: {str(e)}"
        )


@router.post("/get_strategic_moves")
async def get_strategic_moves(
    session_id: str, game_state: GameState, context: str = ""
) -> Dict:
    """
    Generate strategic moves for the current game state using AI agents.

    Args:
        session_id: The game session identifier
        game_state: Current game state
        context: Additional business context

    Returns:
        List of strategic move options generated by AI
    """
    try:
        if session_id not in game_sessions:
            raise HTTPException(status_code=404, detail="Session not found")

        engine = game_sessions[session_id]

        # Generate strategic moves using AI agent
        strategic_moves = await engine.generate_strategic_moves(
            game_state, context
        )

        return {
            "session_id": session_id,
            "moves": [move.model_dump() for move in strategic_moves],
            "message": "Strategic moves generated successfully using AI agents",
        }

    except Exception as e:
        raise HTTPException(
            status_code=500, detail=f"Error generating moves: {str(e)}"
        )


@router.post("/get_decision_tree")
async def get_decision_tree(
    session_id: str,
    game_state: GameState,
    selected_move: StrategyMove,
    depth: int = 2,
) -> Dict:
    """
    Generate decision tree for a selected move using simplified simulation.

    Args:
        session_id: The game session identifier
        game_state: Current game state
        selected_move: The strategic move to analyze
        depth: Search depth (default: 2)

    Returns:
        Decision tree structure with nodes and scores
    """
    try:
        if session_id not in game_sessions:
            raise HTTPException(status_code=404, detail="Session not found")

        engine = game_sessions[session_id]

        # Define varied opponent responses based on move category
        opponent_templates = [
            {
                "name": "Aggressive Price Competition",
                "base_score": 60,
                "counter_moves": [
                    {"name": "Value-Added Services", "score_mod": 15},
                    {"name": "Premium Brand Positioning", "score_mod": 10},
                    {"name": "Cost Leadership Response", "score_mod": 8},
                ],
            },
            {
                "name": "Product Innovation Launch",
                "base_score": 70,
                "counter_moves": [
                    {"name": "Fast Follower Strategy", "score_mod": 18},
                    {"name": "Differentiated Features", "score_mod": 22},
                    {"name": "Market Niche Focus", "score_mod": 14},
                ],
            },
            {
                "name": "Aggressive Marketing Campaign",
                "base_score": 55,
                "counter_moves": [
                    {"name": "Social Media Engagement", "score_mod": 12},
                    {"name": "Strategic Partnerships", "score_mod": 16},
                    {"name": "Customer Loyalty Program", "score_mod": 10},
                ],
            },
        ]

        # Build decision tree structure
        tree = {
            "root": {
                "id": "root",
                "level": 0,
                "player": "Us",
                "move": selected_move.move_name,
                "description": selected_move.description,
                "score": selected_move.expected_score
                if selected_move.expected_score
                else 75.0,
                "children": [],
            }
        }

        # Use the base score from selected move to calculate variations
        base_score = (
            selected_move.expected_score
            if selected_move.expected_score
            else 75.0
        )

        # For each opponent template, create response nodes
        for i, template in enumerate(opponent_templates):
            opponent_node = {
                "id": f"comp-{i + 1}",
                "level": 1,
                "player": "Competitor",
                "move": template["name"],
                "score": template["base_score"],
                "children": [],
            }

            # Find the best counter-move score for this branch
            best_counter_score = max(
                [
                    base_score + cm["score_mod"]
                    for cm in template["counter_moves"]
                ]
            )

            # Create counter-move nodes with varied scores
            for j, counter_move in enumerate(template["counter_moves"]):
                counter_score = min(
                    100, base_score + counter_move["score_mod"]
                )
                counter_node = {
                    "id": f"our-{i + 1}-{j + 1}",
                    "level": 2,
                    "player": "Us",
                    "move": counter_move["name"],
                    "score": round(counter_score, 1),
                    "isOptimal": counter_score == best_counter_score,
                }
                opponent_node["children"].append(counter_node)

            tree["root"]["children"].append(opponent_node)

        return {
            "session_id": session_id,
            "tree": tree,
            "message": "Decision tree generated successfully",
        }

    except Exception as e:
        raise HTTPException(
            status_code=500, detail=f"Error generating decision tree: {str(e)}"
        )


@router.post("/add_business_goal", response_model=ActionResponse)
async def add_business_goal(request: UserActionRequest) -> ActionResponse:
    """
    Add or update a business goal for a user.

    Args:
        request: User action request with business goal

    Returns:
        Action response
    """
    try:
        # For now, just return a placeholder response
        return ActionResponse(
            selected_move_id="PLACEHOLDER",
            reasoning="Business goal added successfully",
        )
    except Exception as e:
        raise HTTPException(
            status_code=500, detail=f"Error adding business goal: {str(e)}"
        )


@router.get("/health")
async def health_check() -> Dict:
    """
    Health check endpoint.

    Returns:
        Service status
    """
    return {
        "status": "healthy",
        "service": "Strategic Wargame AI",
        "active_sessions": len(game_sessions),
    }


@router.get("/test")
async def test_endpoint() -> Dict:
    """
    Simple test endpoint with dummy data.

    Returns:
        Test response
    """
    return {
        "status": "success",
        "message": "API is working! This is dummy test data.",
        "sample_strategic_moves": [
            {
                "move_id": "TEST_001",
                "move_name": "Expand to New Markets",
                "description": "Enter emerging markets in Southeast Asia",
                "category": "Market Expansion",
            },
            {
                "move_id": "TEST_002",
                "move_name": "Launch AI Product",
                "description": "Develop AI-powered product line",
                "category": "Product Innovation",
            },
        ],
        "business_goal_example": "maximize market share",
        "note": "No Google API connection needed - all dummy data",
    }
